<!DOCTYPE html> <html lang=en> <head> <meta charset=utf-8> <title>Overview of the Artifact - Whip</title> <meta name=description content="ICFP Paper Artifact Evaluation"/> <link href="../assets/stylesheets/application-6771d460.css" rel=stylesheet /> <link rel=stylesheet href="//cdnjs.cloudflare.com/ajax/libs/hopscotch/0.2.6/css/hopscotch.min.css"> <meta name=viewport content="width=device-width, initial-scale=1.0"/> <link rel="shortcut icon" href="../assets/images/favicon-e9623b04.png"> <script src="//cdnjs.cloudflare.com/ajax/libs/hopscotch/0.2.6/js/hopscotch.min.js"></script> <script src="//use.typekit.net/kgv0shi.js"></script> <script src="https://code.createjs.com/createjs-2015.11.26.min.js"></script> <script>try{Typekit.load();}catch(e){}</script> </head> <body class="page-Overview of the Artifact layout-docs page-sub"> <div id=header class="navigation navbar-static-top"> <div class=container> <div class=row> <div class=col-xs-12> <div class=navbar-header> <div class=navbar-brand> <a class=logo href="../index.html">Whip</a> </div> <button class="navbar-toggle white" type=button> <span class=sr-only>Toggle navigation</span> <span class=icon-bar></span> <span class=icon-bar></span> <span class=icon-bar></span> </button> </div> <div class="buttons hidden-xs"> <nav class=navigation-links role=navigation> <ul class="external-links white nav navbar-nav navbar-right"> <li class=github> <a href="https://github.com/wayetender/whip"><svg id=svg-download xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" style="enable-background:new 0 0 14 14;"> <path d="M13,0H1C0.5,0,0,0.5,0,1v12c0,0.5,0.5,1,1,1h4.7c0,0,0,0,0-0.1c0-0.2,0-0.6,0-1.1c-1.8,0.4-2.2-0.9-2.2-0.9 c-0.3-0.8-0.7-1-0.7-1c-0.6-0.4,0-0.4,0-0.4c0.7,0,1,0.7,1,0.7c0.6,1,1.5,0.7,1.9,0.5c0.1-0.4,0.2-0.7,0.4-0.9c-1.5-0.2-3-0.7-3-3.2 c0-0.7,0.3-1.3,0.7-1.8C3.7,5.8,3.5,5.1,3.9,4.2c0,0,0.6-0.2,1.8,0.7c0.5-0.1,1.1-0.2,1.6-0.2c0.6,0,1.1,0.1,1.6,0.2 c1.3-0.8,1.8-0.7,1.8-0.7c0.4,0.9,0.1,1.6,0.1,1.7c0.4,0.5,0.7,1,0.7,1.8c0,2.5-1.5,3.1-3,3.2C8.7,11.1,9,11.5,9,12.1 c0,0.9,0,1.6,0,1.8c0,0,0,0,0,0.1h4c0.5,0,1-0.5,1-1V1C14,0.5,13.5,0,13,0z"/> </svg> GitHub</a> </li> </ul> <ul class="main-links white nav navbar-nav navbar-right"> <li class=li-under><a href="index.html">Documentation</a></li> </ul> <ul class="main-links white nav navbar-nav navbar-right"> <li class=li-under><a href="https://katacoda.com/wayetender/scenarios/whip-calculator-quickstart">Demo</a></li> </ul> </nav> </div> </div> </div> </div> </div> <div class=sidebar-overlay></div> <aside id=sidebar class="sidebar sidebar-default sidebar-fixed-right" role=navigation> <div class="sidebar-header header-cover"> <div class=sidebar-image> <img src="../assets/images/favicon-e9623b04.png" width=50px height=50px> </div> </div> <ul class="main nav sidebar-nav"> <li class=first><a href="https://katacoda.com/wayetender/scenarios/whip-calculator-quickstart">Demo</a></li> <li class=""><a href="index.html">Docs</a></li> <li class=github><a href="https://github.com/wayetender/whip"><svg id=svg-download xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" style="enable-background:new 0 0 14 14;"> <path d="M13,0H1C0.5,0,0,0.5,0,1v12c0,0.5,0.5,1,1,1h4.7c0,0,0,0,0-0.1c0-0.2,0-0.6,0-1.1c-1.8,0.4-2.2-0.9-2.2-0.9 c-0.3-0.8-0.7-1-0.7-1c-0.6-0.4,0-0.4,0-0.4c0.7,0,1,0.7,1,0.7c0.6,1,1.5,0.7,1.9,0.5c0.1-0.4,0.2-0.7,0.4-0.9c-1.5-0.2-3-0.7-3-3.2 c0-0.7,0.3-1.3,0.7-1.8C3.7,5.8,3.5,5.1,3.9,4.2c0,0,0.6-0.2,1.8,0.7c0.5-0.1,1.1-0.2,1.6-0.2c0.6,0,1.1,0.1,1.6,0.2 c1.3-0.8,1.8-0.7,1.8-0.7c0.4,0.9,0.1,1.6,0.1,1.7c0.4,0.5,0.7,1,0.7,1.8c0,2.5-1.5,3.1-3,3.2C8.7,11.1,9,11.5,9,12.1 c0,0.9,0,1.6,0,1.8c0,0,0,0,0,0.1h4c0.5,0,1-0.5,1-1V1C14,0.5,13.5,0,13,0z"/> </svg> GitHub</a></li> </ul> <div class=divider></div> <ul class="external nav sidebar-nav"> <li class=""><a class="v-btn gray sml" href="/" %>GitHub</a></li> </ul> </aside> <div class=container> <div class=col-md-4> <div class="docs-sidebar hidden-print affix-top" role=complementary> <ul class="nav docs-sidenav"> <li> <a href="index.html">Home</a> </li> <li> <a href="getting-started.html">Getting Started</a> </li> <li> <a href="benchmarks.html">Benchmarks</a> </li> </ul> </div> </div> <div id=main-content class=col-md-8 role=main> <div class=bs-docs-section> <h1 id=overview-of-the-artifact> <a name=overview-of-the-artifact class=anchor href="#overview-of-the-artifact">&raquo;</a> Overview of the Artifact </h1> <p>This is the overview document for the Whip artifact (paper #58). This document&#39;s intended audience is the ICFP 2017 artifact evaluators.</p> <p>As prescribed by the Artifact Submission instructions, we have broken this document in two sections: a <a href="#getting-started">Getting Started</a> guide, which describes the setup instructions and basic testing, and an <a href="#evaluation">Evaluation</a> section, which gives step-by-step instructions for how to evaluate the artifact.</p> <h2 id=getting-started> <a name=getting-started class=anchor href="#getting-started">&raquo;</a> Getting Started </h2> <p>The artifact provided to you contains the following assets:</p> <ul> <li><a name=whip /><a href="#whip"><code>whip</code></a> subdirectory: <code>v0.1.0</code> tag of the Whip Git repository, which includes: <ul> <li>the static documentation website, located in the <code>web</code> subdirectory. You can view this document on your browser by opening <code>web/build/docs/artifact-eval.html</code> in your browser. </li> <li>the Whip source code, located in the <code>whip</code> subdirectory. </li> <li>the Whip benchmarks located in the <code>benchmarks</code> subdirectory` as described in Sections 6 and 7 of the paper. </li> </ul> </li> <li><a name=docker-images /><a href="#docker-images"><code>docker-images</code></a> subdirectory: the pre-built Docker container for the Whip source code. </li> <li><a name=whip-calculator-example /><a href="#whip-calculator-example"><code>whip-calculator-example</code></a> subdirectory: a simple Thrift microservices application used to show how Whip works in a simplified setting and in particular to demonstrate high-order contract checking as described in the paper. </li> <li><a name=overview-html /><a href="#overview-html"><code>overview.html</code></a>: this document, in simplified HTML format. </li> </ul> <h3 id=online-resources> <a name=online-resources class=anchor href="#online-resources">&raquo;</a> Online Resources </h3> <p>For the latest version of Whip, feel free to look at the following online resources:</p> <ul> <li><strong><a href="https://github.com/wayetender/whip">Whip Github Repository</a></strong> which hosts the Whip Git repository. The code provided in the artifact can be found online in the <code>v0.1.0</code> tag. </li> <li><strong><a href="https://hub.docker.com/r/wayetender/whip/">Docker Hub Whip Repository</a></strong> which contains automatically-built Docker images based on the above Github repo. </li> <li><strong><a href="https://github.com/wayetender/whip-calculator-example">Whip Calculator Quickstart</a></strong> which hosts the Calculator quickstart tutorial described above. </li> <li><strong><a href="http://whip.services">Whip website</a></strong> which is Whip&#39;s website that is simply an easily-accessible version of the <code>web</code> directory of the Git repository. </li> </ul> <h3 id=prerequisites> <a name=prerequisites class=anchor href="#prerequisites">&raquo;</a> Prerequisites </h3> <p>To run the benchmarks, you will need to have a recent version of Docker installed on your computer. The artifact was developed using Docker version 17.03.1-ce, build c6d412e. For instructions on downloading and installing Docker, please see <a href="https://www.docker.com/get-docker">https://www.docker.com/get-docker</a>.</p> <p>You must also be comfortable using a UNIX-like terminal with a modern shell (e.g., bash). Though the steps should reasonably work on a Windows-based operating system (as most of the functionality of Whip is contained in a Docker container), it has not been tested on one.</p> <h3 id=installation> <a name=installation class=anchor href="#installation">&raquo;</a> Installation </h3> <p>To start using Whip you must first create the Whip base image. The base image contains the Whip adapter and interposition library described in the beginning of Section 6 of the paper. We refer to the interposition library in this document and in the source code simply as the <em>shim</em>.</p> <p>We provide you with three ways to create the Whip base image: either by building the container manually from source, or by importing the image directly, or by pulling from the Docker Hub. We note that building the container manually, which can be done in one command, is computationally intensive and can take upwards of 30 minutes. In contrast, importing the image directly takes seconds.</p> <ul> <li><p><strong>Option 1:</strong> Manually building the base image</p> <p>Change your working directory to the <code>whip/whip</code> subdirectory (i.e., where the <code>Dockerfile</code> file is contained) and perform the following command:</p> <pre class="highlight plaintext"><code>docker build -t wayetender/whip .
</code></pre></li> <li><p><strong>Option 2:</strong> Importing the supplied base image</p> <p>Change your working directory to the <code>docker-images</code> subdirectory (i.e., where the <code>whip.tar</code> file is contained) and perform the following command:</p> <pre class="highlight plaintext"><code>docker load -i whip.tar
</code></pre></li> <li><p><strong>Option 3:</strong> From the Docker Hub</p> <p>Though seemingly not recommended by the AEC (as it is an online resource), the preferred technique to load a Docker container is to pull the image from the Docker Hub.</p> <pre class="highlight plaintext"><code>docker pull wayetender/whip:v0.1.0 
</code></pre></li> </ul> <p>You can test the image was installed correctly by running the <code>adapter</code> command inside the container. That is, you should see be able to reproduce the following output on your computer.</p> <pre class="highlight plaintext"><code>$ docker run wayetender/whip adapter
usage: adapter [adapterconfigfile.yaml]
</code></pre><p>Once the base image is installed, you can now <em>evaluate</em> the artifact, which we describe in the next section.</p> <h2 id=evaluation> <a name=evaluation class=anchor href="#evaluation">&raquo;</a> Evaluation </h2> <p>In this section we propose how to evalute this artifact.</p> <p>We believe that the artifact should be evaluated with two criteria. First, it should be evaluated on its ability to monitor services with the contract language described in Section 2. In particular, it should demonstrate transparent interception and inspection on the contents of messages (i.e., treating the services as black boxes without requiring code changes) and also the ability to correctly report blame. Second, the artifact should faithfully demonstrate the performance evaluation result trends described in Figure 11 and Section 7 of the paper.</p> <p>To show the first criterion, we will perform a step-by-step tutorial of the Whip adapter using a simple microservices toy app. In particular, it will concretely demonstrate the following in order (with each feature&#39;s description in the ICFP paper given in parentheses):</p> <ol> <li>Whip can be deployed on an application with no code changes (bottom of p2). Additionally, Whip can operate under partial deployment (i.e., only one of the services will have a Whip adapter) (bottom of p2). </li> <li>Whip can capture first-order contract failures (bottom of p4). </li> <li>Whip can capture higher-order contract failures (top of p5). In particular, Whip uses imprecise blame under partial deployment (end of Section 3.3). </li> <li>Whip uses precise blame under full deployment (Section 3.4) </li> <li>Whip uses precise blame for indexed contracts (end of Section 2) </li> </ol> <p>To show the second criterion, we provide a command to generate the benchmarks and images from Figure 11.</p> <h3 id=calculator-example> <a name=calculator-example class=anchor href="#calculator-example">&raquo;</a> Calculator Example </h3> <p>In this section we provide a simple tutorial for the features of Whip with a simple microservices application.</p> <p>The microservices application is a simple distributed calculator. It consists of three services: an <em>adder</em>, which performs numeric addition (which you could imagine being an extremely computationally expensive operation that must be distributed), a <em>discovery</em> service for adders, and a <em>client</em> which issues addition commands. The workflow of the application is:</p> <ol> <li>An adder joins the set of available adders by invoking the <code>register_adder</code> operation on the adder service that includes the address where the adder can be invoked. </li> <li>A client requests the address of an available adder by invoking the <code>get_adder_info</code>. The discovery service returns a random available adder to the client. </li> <li>With the given adder service address, the client invokes the <code>add</code> operation on the adder. The adder performs the computation and returns the result to the client. </li> </ol> <p>The source code for this application is in the <code>whip-calculator-example</code>. The Thrift network protocol is defined in <code>src/calc.thrift</code>.</p> <p>The first step is to build the containers. This can be done with the <code>docker-compose build</code> command.</p> <pre class="highlight plaintext"><code>$ docker-compose build
Building adder
...
</code></pre><p>We can then run the client by using the <code>docker-compose run client</code> command. When run, we will be presented with the calculator client. This command will also start up the adder and discovery service. For now, let&#39;s just use the <code>quit</code> command.</p> <pre class="highlight plaintext"><code>$ docker-compose run client
Creating whipcalculatorexample_adder_1
Creating whipcalculatorexample_discovery_1
connected to discovery service discovery:8000
Available Commands:
add [n1] [n2]                   - Get a random adder and compute n1+n2
register_adder [host] [port]    - Register new adder service
quit                            - Exits the program
&gt; quit
</code></pre><p>We can use the <code>logs</code> docker-compose command to check the status of the adder and discovery service.</p> <pre class="highlight plaintext"><code>$ docker-compose logs 
Attaching to whipcalculatorexample_discovery_1, whipcalculatorexample_adder_1
adder_1      | 05/14/2017 12:25:49 PM INFO adder service listening on 8001
adder_1      | 05/14/2017 12:25:49 PM INFO registered with adder discovery on discovery:8000 as adder-8001
discovery_1  | 05/14/2017 12:25:46 PM INFO adder discovery service listening on 7999
discovery_1  | 05/14/2017 12:25:49 PM DEBUG registering adder service adder:8001
</code></pre><p>Note that the adder and discovery services are still running. To view their status, run the <code>docker-compose ps</code> command. To stop them, run <code>docker-compose down</code>.</p> <pre class="highlight plaintext"><code>$ docker-compose ps
              Name                       Command         State                        Ports                       
-----------------------------------------------------------------------------------------------------------------
whipcalculatorexample_adder_1       ./run_adder.sh       Up      0.0.0.0:38001-&gt;38001/tcp, 0.0.0.0:8001-&gt;8001/tcp 
whipcalculatorexample_discovery_1   ./run_discovery.sh   Up      0.0.0.0:38000-&gt;38000/tcp, 0.0.0.0:8000-&gt;8000/tcp 
$ docker-compose down
Stopping whipcalculatorexample_discovery_1 ... done
Stopping whipcalculatorexample_adder_1 ... done
Removing whipcalculatorexample_client_run_1 ... done
Removing whipcalculatorexample_discovery_1 ... done
Removing whipcalculatorexample_adder_1 ... done
Removing network whipcalculatorexample_default
</code></pre><p>Let&#39;s now run the client to perform the third step of the workflow.</p> <pre class="highlight plaintext"><code>% docker-compose run client
connected to discovery service discovery:8000
Available Commands:
add [n1] [n2]                   - Get a random adder and compute n1+n2
register_adder [host] [port]    - Register new adder service
quit                            - Exits the program
&gt; add 2 2
2 + 2 = 3
&gt; quit
$
</code></pre><p><em>Uh oh.</em> Two plus two does not equal three. Let&#39;s use Whip to pinpoint the error. (Though, it should be no surprise, the adder has not held up its part of the bargain to perform the addition correctly.)</p> <blockquote> <p><strong>Objective 1:</strong> Whip can be deployed on an application with no code changes (bottom of p2). Additionally, Whip can operate under partial deployment (i.e., only one of the services will have a Whip adapter) (bottom of p2).</p> </blockquote> <p>We will start by installing an adapter on the client to catch the error.</p> <p>To do this we will need a Whip contract and a Whip adapter configuration. For the tutorial, we have provided both: the contract is located in <code>whip/calculator.whip</code> and the configuration file for the client is located in <code>adapter_client.yaml</code>.</p> <p>Of particular interest in the client proxy string:</p> <pre class="highlight plaintext"><code>  - discovery:8000 mapstoservice AdderDiscovery
</code></pre><p>This states that that there is an <code>AdderDiscovery</code> service at the <code>discovery</code> host with port <code>8000</code>.</p> <p>In order to deploy the client with the Whip adater with the above configuration, we need to create an adapter and use the shim library on the client. The <code>shim</code> command is a shell script that instructs the operating system to preload the interposition library to intercept on new network connections (described in more detail in Section 3).</p> <p>The entry point of the client application is in the <code>run_client.sh</code> script. Inspecting the file, we can see that the adapter is already created in the first line of the script. The only remaining step is to add the shim library. We can do that by modifying the last line of the <code>run_client.sh</code> script from:</p> <pre class="highlight plaintext"><code>python src/client.py discovery 8000
</code></pre><p>to</p> <pre class="highlight plaintext"><code>shim python src/client.py discovery 8000
</code></pre><p>This will successfully install the Whip adapter on the client, without any code changes to the client itself.</p> <blockquote> <p><strong>Objective 2:</strong> Whip can capture first-order contract failures (bottom of p4).</p> </blockquote> <p>With the adapter installed we can bring down the application, rebuild the containers (note: not the service applications themselves), and run the client again:</p> <pre class="highlight plaintext"><code>$ docker-compose down
...
$ docker-compose build
...
$ docker-compose run cient
...
$ docker-compose run client ./run_client.sh
connected to discovery service discovery:8000
Available Commands:
add [n1] [n2]                   - Get a random adder and compute n1+n2
register_adder [host] [port]    - Register new adder service
quit                            - Exits the program
&gt; add 2 2
[Whip] Contract Failure: Failed postcondition  result == a + b 
     Occurring at: service Adder with default index at adder:8001 vouched for by unknown
     Variables: 
       - a = 2
       - b = 2
       - result = 3
2 + 2 = 3
&gt; 
</code></pre><p>Success! I mean, failure! We have a contract failure, that is. We have successfully captured a first-order contract failure (i.e., that <code>2 + 2</code> is not equal to <code>3</code>).</p> <blockquote> <p><strong>Objective 3:</strong> Whip can capture higher-order contract failures (top of p5). In particular, Whip uses imprecise blame under partial deployment (end of Section 3.3).</p> </blockquote> <p>For our next objective (achieving higher-order blame), we simply need to inspect the blame labels in the previous report and the given contract.</p> <p>The line of interest is:</p> <pre class="highlight plaintext"><code>Occurring at: service Adder with default index at adder:8001 vouched for by unknown
</code></pre><p>In this line, we can see that the error came from the adder service. By inspecting the <code>adapter_client.yaml</code> file, we can see that the client is not initially configured to know about the location of adder service. Instead, Whip only knows about the adder service through the call to <code>get_adder_info</code>. (If you are curious, you can remove the <code>@identifies</code> tag for the <code>get_adder_info</code> Whip contract and the contract would not be checked.)</p> <p>Additionally, the service was <code>vouched for by unknown</code>. That is, the imprecise blame label was used.</p> <blockquote> <p><strong>Objective 4:</strong> Whip uses precise blame under full deployment (Section 3.4)</p> </blockquote> <p>To show the last objective, we must install an adapter on all services. It turns out that the other services were already enhanced and we only need to make the client aware of the discovery service (which can be confirmed by inspecting the <code>run_adder.sh</code> and <code>run_discovery.sh</code> scripts). We can make the client aware of the discovery Whip adapter with a simple configuration change for the client adapters.</p> <p>Change the last line of <code>adapter_client.yaml</code> file from</p> <pre class="highlight plaintext"><code>  - discovery:8000 mapstoservice AdderDiscovery
</code></pre><p>to:</p> <pre class="highlight plaintext"><code>  - discovery:8000 proxiedby discovery:38000 mapstoservice AdderDiscovery
</code></pre><p>With this we can bring down the application, rebuild the containers (note: not the applications themselves), and run the client again:</p> <pre class="highlight plaintext"><code>$ docker-compose down
...
$ docker-compose build
...
$ % docker-compose run client
Creating network "whipcalculatorexample_default" with the default driver
Creating whipcalculatorexample_adder_1
Creating whipcalculatorexample_discovery_1
connected to discovery service discovery:8000
Available Commands:
add [n1] [n2]                   - Get a random adder and compute n1+n2
register_adder [host] [port]    - Register new adder service
quit                            - Exits the program
&gt; add 2 2
[Whip] Contract Failure: Failed postcondition  result == a + b 
     Occurring at: service Adder with default index at adder:8001 vouched for by adder
     Variables: 
       - a = 2
       - b = 2
       - result = 3

2 + 2 = 3
&gt; quit
</code></pre><p>We can see now in this case the adder service was vouched for by the adder adapter (the name &quot;adder&quot; comes from the <code>whip/adapter_adder.yaml</code> configuration file).</p> <blockquote> <p><strong>Objective 5:</strong> Whip uses precise blame for indexed contracts (end of Section 2)</p> </blockquote> <p>Finally, we show how Whip tracks indexed contracts with a special indexed contract form given in <code>whip/calculator.indexed.whip</code>. This indexed contract provides adder services only when the first operand (<code>a</code>) is exactly equal to 1. In all other cases, the adder service and discovery service do not vouch for its behavior. In other words, if the client provides an <code>a</code> operand to the adder that is not exactly <code>1</code> then it will vouch for the behavior of the adder service.</p> <p>Modify each Whip configuration file (<code>adapter_adder.yaml</code>, <code>adapter_client.yaml</code>, and <code>adapter_discovery.yaml</code>) to have the <code>spec</code> field be <code>whip/calculator.indexed.whip</code> instead of <code>whip/calculator.whip</code>.</p> <p>Once the configuration files are modified, we can rebuild the containers and try running the client with different arguments for <code>a</code>:</p> <pre class="highlight plaintext"><code>$ docker-compose down
...
$ docker-compose build
...
$ docker-compose run client
connected to discovery service discovery:8000
Available Commands:
add [n1] [n2]                   - Get a random adder and compute n1+n2
register_adder [host] [port]    - Register new adder service
quit                            - Exits the program
&gt; add 1 1
[Whip] Contract Failure: Failed postcondition  result == a + b 
     Occurring at: service Adder with index 1 at adder:8001 vouched for by adder
     Variables: 
       - a = 1
       - b = 1
       - result = 1

1 + 1 = 1
&gt; add 2 2
[Whip] Contract Failure: Failed postcondition  result == a + b 
     Occurring at: service Adder with index 2 at adder:8001 vouched for by client
     Variables: 
       - a = 2
       - b = 2
       - result = 3

2 + 2 = 3
&gt; quit
</code></pre><p>Note that the <code>adder</code> service was blamed in the first run but not in the second, as the client introduced the new Adder service in the second run (as <code>a</code> was not equal to 1).</p> <hr/> <h4 id=bonus-fixing-the-adder-and-pre-condition-errors-> <a name=bonus-fixing-the-adder-and-pre-condition-errors- class=anchor href="#bonus-fixing-the-adder-and-pre-condition-errors-">&raquo;</a> Bonus (fixing the adder and pre-condition errors) </h4> <p>If you are so interested, you can also fix the broken adder by inspecting and modifing Line 18 of <code>src/adder.py</code>. Just change <code>return a + b - 1</code> to <code>return a + b</code>. By bringing down the services and bringing them back (as was done above), the error will go away.</p> <p>You can also see client-side errors as follows:</p> <pre class="highlight plaintext"><code>$ docker-compose down
...
$ docker-compose build
...
$ docker-compose run client
connected to discovery service discovery:8000
Available Commands:
add [n1] [n2]                   - Get a random adder and compute n1+n2
register_adder [host] [port]    - Register new adder service
quit                            - Exits the program
&gt; add 0 0
0 + 0 = 0
&gt; quit
$ docker-compose logs --tail 7 adder
Attaching to whipcalculatorexample_adder_1
adder_1      | [Whip] Contract Failure: Failed precondition for RPC add ( a &gt; 0 and b &gt; 0 )
adder_1      |   Blaming: client (precondition failure)
adder_1      |   Occurring at: service Adder with default index at adder:8001 vouched for by adder
adder_1      |   Variables: 
adder_1      |     - a = 0
adder_1      |     - b = 0
adder_1      | 
</code></pre><p>Note that in this case, the precondition error (providing a nonpositive integer) was caught in the <code>adder</code> service&#39;s Whip adapter. This is because, as described in Section 3.4, when using enhanced communication adapters will share the burden of contract checking. Note though that still the client was blamed.</p> <h3 id=benchmarks> <a name=benchmarks class=anchor href="#benchmarks">&raquo;</a> Benchmarks </h3> <p>In this section we describe how to run the benchmarks (don&#39;t worry; it&#39;s just one Docker command).</p> <p>Whip comes with a benchmark test suite that contains three real-world case studies as described in Section 6. The case studies are:</p> <ul> <li><strong>Evernote</strong>: an Evernote Thrift API client. You can find more information about the Evernote API at <a href="https://dev.evernote.com/doc/">https://dev.evernote.com/doc/</a>. </li> <li><strong>Chess</strong>: a SOAP-based Xfcc correspondence chess program. You can find more information about the Xfcc protocol at <a href="http://xfcc.org/">http://xfcc.org/</a>. </li> <li><strong>Twitter</strong>: a REST-like Twitter API client. You can find more information about the Twitter API at <a href="https://dev.twitter.com/overview/api">https://dev.twitter.com/overview/api</a>. </li> </ul> <p>The benchmarks are contained in the <code>whip/benchmarks</code> directory. The <code>benchmarks</code> directory is structured as follows:</p> <pre class="highlight plaintext"><code>.
├── docker-compose.yml
├── README.md
├── evernote
│   └── ...
├── chess
│   └── ...
├── twitter
│   └── ...
└── parse_results
    └── ...
</code></pre><p>The benchmarks are run through <a href="https://docs.docker.com/compose/">Docker Compose</a>. The <code>docker-compose.yml</code> file describes the containers that will be run. In this suite, there are four containers:</p> <ul> <li><strong>evernote</strong>: the Evernote test benchmark </li> <li><strong>chess</strong>: the Chess test benchmark </li> <li><strong>twitter</strong>: the Twitter test benchmark </li> <li><strong>parse_results:</strong> produces human-readable plots from raw benchmark data </li> </ul> <h4 id=running-with-docker-compose> <a name=running-with-docker-compose class=anchor href="#running-with-docker-compose">&raquo;</a> Running with Docker Compose </h4> <p>To run the benchmarks, simply set the <code>NUM_OPS</code> environmental variable to the number of operations you want the benchmarks to perform and then run the <code>docker-compose up --build</code> command in the <code>benchmarks</code> directory. The <code>docker-compose.yml</code> file is parameterized by the <code>NUM_OPS</code> variable, which sets the number of operations to run per benchmark. In the &quot;<a href="#anatomy-of-the-benchmarks">Anatomy of the Benchmarks</a>&quot; section, we describe the benchmark&#39;s operation in more detail.</p> <p>Below is an example run in the <code>benchmarks</code> directory and its output with 3,000 operations per benchmark (9,000 operations in total).</p> <pre class="highlight shell"><code><span class="gp">$ </span><span class="nv">NUM_OPS</span><span class="o">=</span>3000 docker-compose up --build
Building parse_results
...
Attaching to benchmarks_parse_results_1, benchmarks_twitter_1, benchmarks_evernote_1, benchmarks_chess_1
evernote_1       | Starting tests
evernote_1       | Done
benchmarks_evernote_1 exited with code 0
chess_1          | Starting tests
chess_1          | Done
benchmarks_chess_1 exited with code 0
twitter_1        | Starting tests
twitter_1        | Done
benchmarks_twitter_1 exited with code 0
parse_results_1  | 
parse_results_1  | ---------------------------------
parse_results_1  |       Benchmarks Complete!       
parse_results_1  | ---------------------------------
parse_results_1  | 
parse_results_1  | Please check the results/images directory.
benchmarks_parse_results_1 exited with code 0
</code></pre><p>After running the benchmark, you can check the <code>results/images</code> directory inside the <code>benchmarks</code> directory to find the following generated images:</p> <div align=center> <p><img src="benchmarks_images/memorychart-81bf218b.png" alt="memorychart.png" style="width: 200px;"/> <img src="benchmarks_images/throughputchart-1d270d95.png" alt="throughputchart.png" style="width: 200px;"/> <img src="benchmarks_images/networkchart-cbf33840.png" alt=Drawing style="width: 200px;"/></p> </div> <ul> <li><p><a name=memorychart-png /><a href="#memorychart-png"><code>memorychart.png</code></a>: This chart shows the resident set size of the adapter and the dashed lines show the sizes of the store on disk. In general, the memory usage of the adapters should level off to be constant, while the store size (shown in dashed lines) should increase linearly.</p> </li> <li><p><a name=throughputchart-png /><a href="#throughputchart-png"><code>throughputchart.png</code></a>: This chart shows the latency of the adapter as the number of requests increases. Each point is the average of the 250 requests around it. In general, the latency of all three benchmarks should not increase as the number of requests increases. The variance, however, may be high depending on the Docker host machine setup.</p> </li> <li><p><a name=networkchart-png /><a href="#networkchart-png"><code>networkchart.png</code></a>: This chart shows the average amount of adapter traffic per operation call. Vertical bars indicate 95% confidence intervals. This chart should remain relatively fixed, with Evernote producing roughly 75 bytes of overhead on average per operation, and Twitter and Chess producing roughly 50 bytes of overhead per operation.</p> </li> </ul> <p>With the exception of the <code>networkchart.png</code> chart, the generated results will vary dramatically in absolute numbers depending on the number of resources given.</p> <div class="alert alert-info" role=alert> <p><strong>Note:</strong> In the ICFP paper, the number of operations chosen was 10,000 (i.e., <code>NUM_OPS=10000</code>). That trial will take about 45 minutes to an hour to complete, depending on the resources available to the Docker containers.</p> </div> <div class="alert alert-danger" role=alert> <p><strong>Warning:</strong> Due to bucketing of the raw output data, it is recommended to run the benchmarks with <strong>at least</strong> 1,00 operations per benchmark (i.e., <code>NUM_OPS=1000</code>), otherwise there will not be enough aggregate data to plot an image.</p> </div> <h4 id=anatomy-of-the-benchmarks> <a name=anatomy-of-the-benchmarks class=anchor href="#anatomy-of-the-benchmarks">&raquo;</a> Anatomy of the Benchmarks </h4> <p>In this section, we describe the structure and operation of the benchmarks.</p> <p>Each benchmark has a common file structure, comprised of the following files:</p> <ul> <li><a name=dockerfile /><a href="#dockerfile"><code>Dockerfile</code></a>: This is the description of how to build the benchmark container. Each container starts from a base Whip container image, and installs benchmark-specific libraries and copies the source code needed to run the benchmark into the container. </li> <li><a name=run-sh /><a href="#run-sh"><code>run.sh</code></a>: This is the script that runs the benchmark. In general, the script will wait for a previous benchmark to complete, then start the server and adapter, then run the test client. Finally the raw benchmark telemetry is copied to the <code>results</code> volume. </li> <li><a name=server-py /><a href="#server-py"><code>server.py</code></a>: This file contains the mock server implementation and also starts the adapter in a subprocess (so that it can track its memory usage). </li> <li><a name=test-py /><a href="#test-py"><code>test.py</code></a>: This is the test client which which will initiate the client requests and track end-to-end latency. </li> <li><a name=adapter-yaml /><a href="#adapter-yaml"><code>adapter.yaml</code></a>: This is the Whip adapter configuration file. Inspect it to see what proxies are being set up and how the contracts are wired together to their network protocols. </li> <li><a name=benchmark_name-whip /><a href="#benchmark_name-whip"><code>{BENCHMARK_NAME}.whip</code></a>: This is the Whip contract file. </li> </ul> <div class="alert alert-warning" role=alert> <p><strong>Caution:</strong> For convenience, TLS verification has been disabled on the test clients as it can be difficult to install certificates on Docker hosts. For more information, see the <em><a href="https://docs.docker.com/engine/security/certificates/">Docker documentation on the topic</a></em>. Once the certificate is installed (and placed in the <code>server.pem</code> file for the mock server), you can remove the verification bypass options in the <code>test.py</code> file.</p> </div> <p>Each benchmark produces a variety of telemetry data, scattered between multiple programs. The raw data files are stored centrally in the <code>results</code> directory when the benchmark completes. Within each results subdirectory (given by the name of the benchmark), the following benchmark raw data files are created:</p> <ul> <li><a name=bytes /><a href="#bytes"><code>bytes</code></a>: Each line corresponds to the number of bytes of Whip-specific information in an enhanced message. The adapter computes this information (i.e., in <code>whip/src/adapter/proxy.py</code>) by computing the byte size difference between the original unenhanced message and the Whip-enhanced message. </li> <li><a name=clientcalls /><a href="#clientcalls"><code>clientcalls</code></a>: Each line corresponds to the number of milliseconds it took for a client request to complete from beginning to end. The <code>test.py</code> test client computes this information by measuring the delay of invoking an RPC. </li> <li><a name=memory /><a href="#memory"><code>memory</code></a>: Each line corresponds to a periodic reading of the adapter process&#39;s resident set size (memory usage) and the size of the store file. The file is comma separated and the columns are, in order, the memory usage of the adapter, the file size of the store file, and the number of requests received at the time of the reading. The <code>server.py</code> file computes this information. </li> <li><a name=times /><a href="#times"><code>times</code></a>: Each line corresponds to the number of milliseconds it took for the mock server to respond to a Whip-proxied request. It is similar to the data in the <code>clientcalls</code> file but is only the portion of time the Whip adapter spent waiting for the server to respond. The adapter computes this information by measuring the delay of invoking the RPC on the mock server while it is proxying a client request. </li> </ul> <p>With this information, the <code>parse_results</code> container uses the <code>parse.py</code> script to compute the final aggregated and joined data that makes up the resulting images (computed by the <code>gen_charts.sh</code> script).</p> </div> </div> </div> <div id=footer class=navigation> <div class=container> <div class=row> <div class=col-xs-12> <div> <ul class="main-links white nav navbar-nav"> <li><a href="https://katacoda.com/wayetender/scenarios/whip-calculator-quickstart">Demo</a></li> </ul> <ul class="main-links white nav navbar-nav"> <li><a href="index.html">Documentation</a></li> </ul> <ul class="external-links white nav navbar-nav"> <li class=github> <a href="https://github.com/wayetender/whip"><svg id=svg-download xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14 14" style="enable-background:new 0 0 14 14;"> <path d="M13,0H1C0.5,0,0,0.5,0,1v12c0,0.5,0.5,1,1,1h4.7c0,0,0,0,0-0.1c0-0.2,0-0.6,0-1.1c-1.8,0.4-2.2-0.9-2.2-0.9 c-0.3-0.8-0.7-1-0.7-1c-0.6-0.4,0-0.4,0-0.4c0.7,0,1,0.7,1,0.7c0.6,1,1.5,0.7,1.9,0.5c0.1-0.4,0.2-0.7,0.4-0.9c-1.5-0.2-3-0.7-3-3.2 c0-0.7,0.3-1.3,0.7-1.8C3.7,5.8,3.5,5.1,3.9,4.2c0,0,0.6-0.2,1.8,0.7c0.5-0.1,1.1-0.2,1.6-0.2c0.6,0,1.1,0.1,1.6,0.2 c1.3-0.8,1.8-0.7,1.8-0.7c0.4,0.9,0.1,1.6,0.1,1.7c0.4,0.5,0.7,1,0.7,1.8c0,2.5-1.5,3.1-3,3.2C8.7,11.1,9,11.5,9,12.1 c0,0.9,0,1.6,0,1.8c0,0,0,0,0,0.1h4c0.5,0,1-0.5,1-1V1C14,0.5,13.5,0,13,0z"/> </svg> GitHub</a> </li> </ul> <ul class="external-links white nav navbar-nav navbar-right"> <li><a href="https://github.com/wayetender/whip/blob/master/web/source/docs/artifact-eval.md">Edit this page</a></li> </ul> </div> </div> </div> </div> </div> <script src="../assets/javascripts/application-d5bde7e6.js"></script> <!--[if lt IE 9]><script src="../assets/javascripts/ie-compat-c141a02d.js"></script><![endif]--> <script>
	APP.initialize();
</script> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99314079-1', 'auto');
  ga('send', 'pageview');

</script> </body> </html>